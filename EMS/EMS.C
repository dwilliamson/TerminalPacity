/*
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*             Expanded Memory Manager Library for Watcom C/C++               *
*                                 by                                         *
*                               Alioth                                       *
*                                                                            *
*                    Copyright (c) 1997 Don Williamson                       *
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Right, before you start using this code, understand this; I can in no way
 be held responsible for the use of this code or indeed the problems that
 may arise from the use of it, be it direct OR inconsequential. The code is
 provided AS IS, without any guarantee whatsoever.
 This code may be used in any Public Domain Software without royalty. However,
 if you wish to use this code in ay Commercial Software, including Shareware,
 please give me credit - it's not necessary, but you lot are the only ones
 who can appreciate what I do - it helps!
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*/

/* ===---===--- Section: INCLUDES ---===---=== */

#include <stdio.h>
#include <string.h>
#include <dos.h>

/* ===---===--- Section: TYPE-DEFINITIONS ---===---=== */

typedef unsigned char byte;                     /* Just cos ASM rules! */
typedef unsigned int  word;
typedef unsigned long dword;

typedef struct EMM_Memory_Store /* Just in case you're organised! :) */
{
   word handle;                                 /* EMM handle number */
   word length;                                 /* Data length (bytes) */
   word pages;                                  /* Number of allocated pages */
} EMMDataStruct, *EMMDataPtr;

struct EMMLogMap_struct
{
   word logpage;                                 /* Logical page to start */
   word phypage;                                 /* Physical page to start */
} EMMLogMap;

/* ===---===--- Section: DEFINITIONS ---===---=== */

#define BUILD_PTR(x, y) (char *)(((dword)x << 16) + y)

/* ===---===--- Section: Global Variables ---===---=== */

byte   EMMError = 0;                            /* Current error number */

/* Error strings generated by the EMM */

byte  *EMMEString[] = { "Success",
                        "Internal software error",
                        "Hardware malfunction",
                        "Unallocated or invalid handle",
                        "Undefined function requested",
                        "No handles available",
                        "Error in save or restore of mapping context",
                        "More pages requested than physically exist",
                        "More pages requested than currently available",
                        "Zero pages requested",
                        "Invalid logical page number",
                        "Illegal physical page number",
                        "Context stack out of memory",
                        "Context save failed, handle already has context stack",
                        "Context restore failed, no context stack for handle",
                        "Invalid subfunction",
                        "Undefined attribute type",
                        "Feature not supported"
                        "Success, portion of region was overwritten",
                        "Length of source or destination region exceeds length of region allocated to either source or destination handle",
                        "Conventional and expanded memory regions overlap",
                        "Offset within logical page exceeds size of logical page",
                        "Region length exceeds 1M"
                        "Source and destination regions have same handle and overlap",
                        "Memory source or destination type undefined",
                        "Specified DMA register not supported | Specified alternate map register set not supported",
                        "All DMA register sets currently allocated | All alternate map register sets currently allocated",
                        "Alternate DMA register sets not supported | Alternate map register sets not supported",
                        "Undefined or unallocated DMA register set | Undefined or unallocated alternate map register set",
                        "Dedicated DMA channels not supported",
                        "Specified dedicated DMA channel not supported",
                        "Duplicate handle name",
                        "Attempted to wrap around 1Mb conventional address space",
                        "Contents of partial page map corrupted or count of mappable segments exceeds total mappable segments",
                        "Operating system denied access" };

/* Error numbers to cross-reference with "EMMEString" */

byte   EMMEMap[35]  = { 0x00, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
                        0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91,
                        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x9A, 0x9B,
                        0x9C, 0x9D, 0x9E, 0x9F, 0xA1, 0xA2, 0xA3, 0xA4 };
byte   EMMVersionMajor;
byte   EMMVersionMinor;
word   EMMFreePages;
word   EMMTotalPages;

/* ===---===--- Section: Prototypes ---===---=== */

/*
Function explanations (the ones you will need to use):

EMM_Check_Install   - Check for the existance of an EMM
EMM_Get_Version     - Get the current EMM version number
EMM_Get_Pages       - Get number of free and total pages in the EMM system
EMM_Alloc           - Setup handle and allocate memory pages
EMM_Map_Memory      - Map logical page into physical page window
EMM_Multiple_Map    - Map multiple logical pages to base physical page
EMM_Get_Page_Frame  - Get page frame base address
EMM_Realloc         - Reallocate pages
EMM_Num_Pages       - Get page count for handle
EMM_Free            - Release handle and memory pages

*/

byte EMM_Check_Install(void);
word EMM_GVA(void);
byte EMM_Get_Version(void);
void EMM_Print_Error(void);
byte EMM_Get_Pages(void);
byte EMM_Alloc(word pages, word *emmh_ptr);
byte EMM_Map_Memory(word, byte, word);
byte EMM_Multiple_Map(word handle, word ppage, byte lpage, word npages);
byte EMM_Get_Page_Frame(byte **pf_ptr);
byte EMM_Free(word emmhand);
byte EMM_Realloc(word, word);
word EMM_Num_Pages(word);
word EMM_Map_Multiple(word, word);
void EMM_Save_State(word);
void EMM_Restore_State(word);

/* ===---===--- Section: Functions ---===---=== */


#pragma aux EMM_Save_State = \
   "mov  ah, 47h" \
   "int  67h" \
   parm [dx] \
   modify [ax];

#pragma aux EMM_Restore_State = \
   "mov  ah, 48h" \
   "int  67h" \
   parm [dx] \
   modify [ax];

byte EMM_Multiple_Map(word handle, word ppage, byte lpage, word npages)
{
   EMMLogMap.logpage = lpage;
   EMMLogMap.phypage = ppage;
   if (!EMM_Map_Multiple(handle, npages)) return(1);
   else return(0);
}

#pragma aux EMM_Map_Multiple = \
   "mov  ax, SEG EMMLogMap" \
   "mov  ds, ax" \
   "lea  si, EMMLogMap" \
   "mov  ax, 5000h" \
   "int  67h" \
   "mov  EMMError, al" \
   parm [dx][cx] \
   modify [ax cx dx ds si] \
   value[ax];

byte EMM_Check_Install(void)
{
   union  REGS input_regs, output_regs;
   struct SREGS segment_regs;
   byte *EMM_Device_Name = "EMMXXXX0";        /* EMM present signature */
   byte *EMM_Device_Real;

   input_regs.h.ah = 0x35;
   input_regs.h.al = 0x67;
   intdosx(&input_regs, &output_regs, &segment_regs);

   EMM_Device_Real = BUILD_PTR(segment_regs.es, 0x0A);

   if (memcmp (EMM_Device_Name, EMM_Device_Real, 8) == 0) return (1);
   else return (0);
}

#pragma aux EMM_GVA = \
   "mov  ah, 46h" \
   "int  67h" \
   value [ax];

byte EMM_Get_Version(void)
{
   word error, value;

   value = EMM_GVA();
   if ((error = value >> 8))
   {
      EMMError = value;
      return(0);
   }
   EMMVersionMinor = value & 15;
   EMMVersionMajor = (value & 255) >> 4;
   return(1);
}

void EMM_Print_Error(void)
{
   byte x;

   for (x = 0; x < 34; x++)
   {
      if (EMMEMap[x] == EMMError)
         printf("\nERROR %xh: %s", EMMEMap[x], EMMEString[x]);
   }
}

#pragma aux EMM_Get_Pages = \
   "mov  ah, 42h" \
   "int  67h" \
   "mov  EMMFreePages, bx" \
   "mov  EMMTotalPages, dx" \
   "mov  EMMError, ah" \
   modify [ax bx dx] \
   value [ah];

byte EMM_Alloc(word pages, word *emmh_ptr)
{
   union REGS inregs, outregs;

   inregs.h.ah = 0x43;
   inregs.x.bx = pages;
   int86(0x67, &inregs, &outregs);
   if (outregs.h.ah == 0)
   {
      *emmh_ptr = outregs.x.dx;
      return(1);
   }
   else
   {
      EMMError = outregs.h.ah;
      return(0);
   }
}

#pragma aux EMM_Map_Memory = \
   "mov  ah, 44h" \
   "int  67h" \
   "mov  EMMError, ah" \
   "cmp  ah, 0" \
   "je   exit1" \
   "mov  ah, 1" \
   "exit1:" \
   parm [dx][al][bx] \
   modify [ax bx dx] \
   value [ah];

byte EMM_Get_Page_Frame(byte **pf_ptr)
{
   union REGS inregs, outregs;

   inregs.h.ah = 0x41;
   int86(0x67, &inregs, &outregs);
   if (outregs.h.ah != 0)
   {
      EMMError = outregs.h.ah;
      return(0);
   }
   else
   {
      *pf_ptr = BUILD_PTR(outregs.x.bx, 0);
      return(1);
   }
}

byte EMM_Free(word emmhand)
{
   union REGS inregs, outregs;

   inregs.h.ah = 0x45;
   inregs.x.dx = emmhand;
   int86(0x67, &inregs, &outregs);
   if (outregs.h.ah == 0) return(1);
   else
   {
      EMMError = outregs.h.ah;
      return(0);
   }
}

#pragma aux EMM_Realloc = \
   "mov  ah, 51h" \
   "int  67h" \
   "mov  EMMError, ah" \
   "cmp  ah, 0" \
   "je   exit2" \
   "mov  ah, 1" \
   "exit2:" \
   parm [dx][bx] \
   modify [ax] \
   value [ah];

#pragma aux EMM_Num_Pages = \
   "mov  ah, 4Ch" \
   "int  67h" \
   "mov  EMMError, ah" \
   parm [dx] \
   modify [ax] \
   value [bx];

void main(void)
{
   word emmhandle, x, y;
   dword count;
   byte *pf_addr;

   printf("\n\n\n");
   if (!EMM_Check_Install())
   {
      printf("Expanded Memory Manager not detected...");
      exit(0);
   }
   printf("Expanded Memory Manager detected...");
   EMM_Get_Page_Frame(&pf_addr);
   if (!EMM_Get_Version())
   {
      EMM_Print_Error();
      exit(0);
   }
   printf("\nEMM Version: %x.%c", EMMVersionMajor, EMMVersionMinor);
   if (EMM_Get_Pages())
   {
      EMM_Print_Error();
      exit(0);
   }
   printf("\nFree EMS Pages: %u", EMMFreePages);
   printf("\nTotal EMS Pages: %u", EMMTotalPages);
   if (!EMM_Alloc(6, &emmhandle))
   {
      EMM_Print_Error();
      exit(0);
   }
//   EMM_Map_Memory(emmhandle, 0, 0);
   EMM_Multiple_Map(emmhandle, 0, 0, 4);
   pf_addr[16000] = 65;
   printf("\n%c", pf_addr[16000]);
   printf("\nAllocated Pages: %u", EMM_Num_Pages(emmhandle));
   EMM_Multiple_Map(emmhandle, 0, 4, 2);
   pf_addr[24000] = 66;
   printf("\n%c", pf_addr[24000]);
   EMM_Multiple_Map(emmhandle, 0, 0, 4);
   EMM_Multiple_Map(emmhandle, 0, 4, 2);
   printf("\n%c", pf_addr[24000]);
   EMM_Multiple_Map(emmhandle, 0, 0, 4);
   EMM_Realloc(emmhandle, 8);
   printf("\nAllocated Pages: %u", EMM_Num_Pages(emmhandle));
   printf("\n%c", pf_addr[16000]);
//   printf("\nNow testing memory...");   
   EMM_Free(emmhandle);
//   EMM_Get_Pages();
//   EMM_Alloc(EMMFreePages, &emmhandle);
//   for (x = 0; x < EMMFreePages; x++)
//   {
//      EMM_Map_Memory(emmhandle, 0, x);
//      for (y = 0; y < (16 * 1024); y++)
//      {
//         pf_addr[y] = 'A';
//      }
//   }
//   count = 0;
//   for (x = 0; x < EMMFreePages; x++)
//   {
//      EMM_Map_Memory(emmhandle, 0, x);
//      for (y = 0; y < (16 * 1024); y++)
//      {
//         if (pf_addr[y] != 'A')
//         {
//            printf("\nException encountered at Physical addr: %x:%x, logical addr: %x. (%lu)", FP_SEG(pf_addr), y, (x * 16) + y, count);
//            count++;
//         }
//      }
//   }
//   EMM_Free(emmhandle);
   printf("\n\n\n");
}

/*

                      =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                       QuickLib EMM Library by Alioth
                      -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

You can map ANY of your 16k pages to the physical page 0 - therefore making
LOTS of memory available... how???...

   allocate your memory.
   map the page you need to the physical page 0.
   get the frame address (physical page 0), where your logical page is mapped.
   access it like it was any normal variable.....!!!!!!

Functions:

------------------------------------------------------------------------------
   EMM_Check_Install();
------------------------------------------------------------------------------

   IN: none.

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   Checks for the existance of an Expanded Memory Manager. If one is detected,
   a true state is returned.


------------------------------------------------------------------------------
   EMM_Get_Version();
------------------------------------------------------------------------------

   IN: none

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   Retrieves the Expanded Memory Manager's version number in Binary Coded
   Decimal format. The major version number (x.) is stored in the global
   variable "EMMVersionMajor", and the minor version number (.x) is stored
   in the global variable "EMMVersionMinor". If a true state was returned,
   the function was successful.


------------------------------------------------------------------------------
   EMM_Get_Pages();
------------------------------------------------------------------------------

   IN: none

   OUT: Error code

   DESCRIPTION:
   Requests amount of pages info. The amount of total pages provided by the
   Expanded Memory Manager is stored in the global variable "EMMTotalPages",
   and the amount of free pages is stored in the global variable -->
   "EMMFreePages". If the function returns a 0, then the operation was
   successful; if not, then the error code is returned.


------------------------------------------------------------------------------
   EMM_Alloc();
------------------------------------------------------------------------------

   IN: word    - Number of pages to allocate
       pointer - Address of the datas handle

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   Allocate a requested amount of 16k pages of memory and assign the group
   of pages a handle. If the state 1 is returned, the operation was
   successful and your memory area now has handle by which you can access it
   with.


------------------------------------------------------------------------------
   EMM_Map_Memory();
------------------------------------------------------------------------------

   IN: word - Data handle
       byte - Physical page number to map to
       word - Logical page number to map from

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   You can map previously allocated memory from the requested logical page,
   to any of the four physical pages that belong to the page frame. Once
   this is done, accessing the memory is merely a case of accessing one of
   the four physical pages (just like normal!). Upon return, if a state 1 is
   received, the operation was successful.


------------------------------------------------------------------------------
   EMM_Multiple_Map();
------------------------------------------------------------------------------

   IN: word - Data handle
       byte - Physical page number to map to (start)
       word - Logical page number to start mapping from
       word - Number of logical pages to map

    OUT: boolean - TRUE | FALSE

    DESCRIPTION:
    Instead of manually mapping individual pages if your memory is greater
    than one page, you can map all your pages from a beginning logical page
    to a beginning physical page. The number of pages to map must not exceed
    the total number of physical pages in the system. Upon return, if a state
    1 is received, the operation was successful.


------------------------------------------------------------------------------
   EMM_Get_Page_Frame();
------------------------------------------------------------------------------

   IN: pointer - Address of variable you want to assign to the frame's address

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   This function points a user-defined variable to the address of the page
   frame, physical page 0. This allows you to access whatever memory is
   located there. As usual, if the state returned is 1, the operation was
   successful.


------------------------------------------------------------------------------
   EMM_Realloc();
------------------------------------------------------------------------------

   IN: word - EMM handle
       word - Number of pages to allocate

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   Reallocates an already allocated EMM handle data area. If the state 1 is
   returned, the operation was successful.


------------------------------------------------------------------------------
   EMM_Num_Pages();
------------------------------------------------------------------------------

   IN: word - EMM handle

   OUT: word - Number of allocated pages

   DESCRIPTION:
   This function will return the total amount of 16k pages that have been
   allocated to a requested EMM handle.


------------------------------------------------------------------------------
   EMM_Free();
------------------------------------------------------------------------------

   IN: word - datas handle

   OUT: boolean - TRUE | FALSE

   DESCRIPTION:
   The final word in EMS manipulation - free that memory!!! :0)

*/
